r"""
fgout_tools module: $CLAW/geoclaw/src/python/geoclaw/fgout_tools.py

Tools to specify an fgout grid for output on a fixed grid at a sequence
of times, regardless of the AMR structure.

"""

from __future__ import absolute_import
from __future__ import print_function
import os
from numpy import sqrt, ma
import numpy
from six.moves import range
from clawpack.geoclaw import topotools


class FGoutGrid(object):

    """
    New class introduced in 5.2.1 to keep store information both about the
    fgout input data and the output generated by a GeoClaw run.
    """

    def __init__(self):

        # GeoClaw input values:
        self.id = ''  # identifier, optional
        self.point_style = None
        self.npts = None
        self.nx = None
        self.ny = None
        self.tstart_out =  None
        self.tend_out = None
        self.nout = None
        self.fgno = None  # grid number
        self.output_format = 'binary'  # 'ascii' or 'binary'

        # Other possible GeoClaw inputs:
        self.x = None
        self.y = None
        self.X = None
        self.Y = None
        self.dx = None
        self.dy = None



    def read_fgout_grids_data(self, fgno, data_file='fgout_grids.data'):
        """
        Read input info for fgout grid number fgno from the data file
        fgout_grids.data, which should have been created by setrun.py.
        This file now contains info about all fgout grids.
        """
        with open(data_file) as filep:
            lines = filep.readlines()
        fgout_input = None
        for lineno,line in enumerate(lines):
            if 'fgno' in line:
                if int(line.split()[0]) == fgno:
                    fgout_input = lines[lineno+1:]
                    #print('Found line %i: %s' % (lineno,line))
                    break

        if fgout_input is None:
            raise ValueError('fgout grid fgno = %i not found in %s' \
                             % (fgno, data_file))

        self.fgno = fgno
        self.tstart_out = float(fgout_input[0].split()[0])
        self.tend_out = float(fgout_input[1].split()[0])
        self.nout = int(fgout_input[2].split()[0])
        self.point_style = point_style = int(fgout_input[3].split()[0])
        output_format = int(fgout_input[4].split()[0])
        if output_format == 1:
            self.output_format = 'ascii'
        elif output_format == 3:
            self.output_format = 'binary'
        print('Reading input for fgno=%i, point_style = %i ' \
                % (self.fgno, self.point_style))
        if point_style == 2:
            self.nx = nx = int(fgmax_input[5].split()[0])
            self.ny = ny = int(fgmax_input[5].split()[1])
            self.x1 = float(fgmax_input[6].split()[0])
            self.y1 = float(fgmax_input[6].split()[1])
            self.x2 = float(fgmax_input[7].split()[0])
            self.y2 = float(fgmax_input[7].split()[1])
        else:
            raise NotImplementedError("fgout not implemented for point_style %i" \
                % point_style)


    def write_to_fgout_data(self, fid):

        print("\n---------------------------------------------- ")
        point_style = self.point_style
        if point_style not in [2]:
            raise NotImplementedError("fgout not implemented for point_style %i" \
                % point_style)
                
        if self.output_format == 'ascii':
            output_format = 1
        elif self.output_format == 'binary':
            output_format = 3
        else:
            raise NotImplementedError("fgout output_format must be ascii or binary")

        # write header, independent of point_style:
        #fid = open(self.input_file_name,'w')
        fid.write("\n")
        fid.write("%i                           # fgno\n" % self.fgno)
        fid.write("%16.10e            # tstart_out\n"  % self.tstart_out)
        fid.write("%16.10e            # tend_out\n"  % self.tend_out)
        fid.write("%i %s           # nout\n" % (self.nout, 11*" "))
        fid.write("%i %s              # point_style\n" \
                            % (self.point_style,12*" "))
        fid.write("%i %s              # output_format\n" \
                            % (output_format,12*" "))

        print('fgout grid %i has point_style = %i' % (self.fgno, point_style))


        if point_style == 2:
            # 2d grid of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.nx is None:
                dx = self.dx
                nx = int(round((x2-x1)/dx)) + 1
                if abs((nx-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((nx-1)*dx + x1 - x2) = ", \
                          abs((nx-1)*dx + x1 - x2))
                    print("         old x2: %22.16e" % x2)
                    x2 = x1 + dx*(nx-1)
                    print("         resetting x2 to %22.16e" % x2)
            else:
                nx = self.nx
                dx = (x2-x1)/(nx+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)

            if self.ny is None:
                dy = self.dy
                if dy is None:
                    dy = dx
                ny = int(round((y2-y1)/dy)) + 1
                if abs((ny-1)*dy + y1 - y2) > 1e-6:
                    print("Warning: abs((ny-1)*dy + y1 - y2) = ", \
                          abs((ny-1)*dy + y1 - y2))
                    print("         old y2: %22.16e" % y2)
                    y2 = y1 + dy*(ny-1)
                    print("         resetting y2 to %22.16e" % y2)
            else:
                ny = self.ny
                dy = (y2-y1)/(ny+1.)
                if self.dy is not None:
                    print("*** Warning: dy specified over-ridden by: ",dy)

            npts = nx*ny

            fid.write("%i  %i %s          # nx,ny\n" \
                                % (nx,ny,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            #fid.close()


            #print("Created file ", self.input_file_name)
            print("   specifying fgout grid with shape %i by %i, with  %i points" \
                    % (nx,ny,npts))
            print("   lower left  = (%15.10f,%15.10f)" % (x1,y1))
            print("   upper right = (%15.10f,%15.10f)" % (x2,y2))
            print("   dx = %15.10e,  dy = %15.10e" % (dx,dy))


