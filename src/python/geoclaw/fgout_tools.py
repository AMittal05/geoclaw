r"""
fgout_tools module: $CLAW/geoclaw/src/python/geoclaw/fgout_tools.py

Tools to specify and work with fgout grids, used to output GeoClaw solutions
on a fixed grid at a sequence of times, regardless of the AMR structure.

Includes:

- class FGoutFrame: used to hold a single frame of fgout output data
- class FGoutGrid: used to specify and store info about an fgout grid, with
                   methods to read and write info to fgout_grids.data
- function make_fgout_fcn_xy: Takes an FGoutFrame object and produces an
            interpolating function that can be evaluated for any (x,y).
- function make_fgout_fcn_xyt: Takes 2 FGoutFrame objects and produces an
            interpolating function that can be evaluated for any (x,y,t)
            at intermediate times.
"""

import os
from numpy import sqrt, ma, mod
import numpy
from six.moves import range


class FGoutFrame(object):

    """
    Class to hold a single frame of fgout data at one output time.
    Several attributes are defined as properties that can be evaluated
    and stored only when needed by the user.
    """

    def __init__(self, fgout_grid=None, frameno=None):
        self.fgout_grid = fgout_grid
        self.frameno = frameno
        self.t = None
        self.t_hms = None           # string in h:m:s format
        self.X = None
        self.Y = None
        self.x = None
        self.y = None
        self.delta = None           # (dx,dy)
        self.extent_centers = None  # defined by fgout points
        self.extent_edges = None    # extended so points are cell centers
        self.drytol = 1e-3          # used for computing u,v from hu,hv

        # private attributes for those that are only created if
        # needed by the user:
        self._h = None
        self._hu = None
        self._hv = None
        self._eta = None
        self._B = None
        self._u = None
        self._v = None
        self._s = None
        self._hss = None

    # Define attributes such as h as @properties with lazy evaluation:
    # the corresponding array is created and stored only when first
    # accessed by the user.  Those not needed are not created.

    @property
    def h(self):
        """depth"""
        if self._h is None:
            #print('+++ setting _h...')
            self._h = self.q[0,:,:]
        #print('+++ getting _h...')
        return self._h

    @property
    def hu(self):
        """momentum h*u"""
        if self._hu is None:
            self._hu = self.q[1,:,:]
        return self._hu

    @property
    def u(self):
        """speed u, computed as hu/h or set to 0 if h<self.drytol"""
        if self._u is None:
            self._u = numpy.divide(self.hu, self.h,\
                              out=numpy.zeros(self.h.shape, dtype=float), \
                              where=(self.h>self.drytol))
        return self._u

    @property
    def hv(self):
        """momentum h*v"""
        if self._hv is None:
            self._hv = self.q[2,:,:]
        return self._hv

    @property
    def v(self):
        """speed v, computed as hv/h or set to 0 if h<self.drytol"""
        if self._v is None:
            self._v = numpy.divide(self.hv, self.h,\
                              out=numpy.zeros(self.h.shape, dtype=float), \
                              where=(self.h>self.drytol))
        return self._v

    @property
    def eta(self):
        """surface eta = h+B"""
        if self._eta is None:
            self._eta = self.q[-1,:,:]
        return self._eta

    @property
    def B(self):
        """topography"""
        if self._B is None:
            self._B = self.q[-1,:,:] - self.q[0,:,:]
        return self._B

    @property
    def s(self):
        """speed s = sqrt(u**2 + v**2)"""
        if self._s is None:
            self._s = numpy.sqrt(self.u**2 + self.v**2)
        return self._s

    @property
    def hss(self):
        """momentum flux h*s**2"""
        if self._hss is None:
            self._hss = self.h * self.s**2
        return self._hss

class FGoutGrid(object):

    """
    New class introduced in 5.9.0 to keep store information both about the
    fgout input data and the output generated by a GeoClaw run.
    """

    def __init__(self,fgno=None,outdir=None,output_format=None):


        # GeoClaw input values:
        self.id = ''  # identifier, optional
        self.point_style = 2  # only option currently supported
        self.npts = None
        self.nx = None
        self.ny = None
        self.tstart =  None
        self.tend = None
        self.nout = None
        self.fgno = fgno
        self.outdir = outdir
        self.output_format = output_format

        # Other possible GeoClaw inputs:
        self.x = None
        self.y = None
        self.X = None
        self.Y = None
        self.dx = None
        self.dy = None

        self._plotdata = None

    # Create plotdata of class clawpack.visclaw.ClawPlotData
    # only when needed for reading GeoClaw output, 
    # since this must be done after fgno, outdir, output_format
    # have been specified:

    @property
    def plotdata(self):
        if self._plotdata is None:
            self._plotdata = self.set_plotdata()
        return self._plotdata

    def set_plotdata(self):
        """
        Create a plotdata, assuming attributes fgno, outdir, output_format
        have all been set.
        """
        from clawpack.visclaw.data import ClawPlotData

        assert self.fgno is not None, '*** fgno must be set'
        assert self.outdir is not None, '*** outdir must be set'
        assert self.output_format is not None, '*** output_format must be set'
        if 0:
            print('+++ creating plotdata for fgno=%i, outdir=%s, format=%s' \
                  % (self.fgno,self.outdir,self.output_format))

        plotdata = ClawPlotData()
        plotdata.outdir = self.outdir
        plotdata.format = self.output_format
        plotdata.file_prefix = 'fgout%s' % str(self.fgno).zfill(4)
        if self.output_format=='binary':
            file_prefix_str = plotdata.file_prefix + '.b'
        else:
            file_prefix_str = plotdata.file_prefix + '.q'
        return plotdata


    def read_fgout_grids_data(self, fgno=None, data_file='fgout_grids.data'):
        """
        Read input info for fgout grid number fgno from the data file
        fgout_grids.data, which should have been created by setrun.py.
        This file now contains info about all fgout grids.
        """
        if fgno is not None:
            self.fgno = fgno
        assert self.fgno is not None, '*** fgno must be set'

        with open(data_file) as filep:
            lines = filep.readlines()
        fgout_input = None
        for lineno,line in enumerate(lines):
            if 'fgno' in line:
                if int(line.split()[0]) == self.fgno:
                    fgout_input = lines[lineno+1:]
                    #print('Found line %i: %s' % (lineno,line))
                    break

        if fgout_input is None:
            raise ValueError('fgout grid fgno = %i not found in %s' \
                             % (fgno, data_file))

        self.tstart = float(fgout_input[0].split()[0])
        self.tend = float(fgout_input[1].split()[0])
        self.nout = int(fgout_input[2].split()[0])
        self.point_style = point_style = int(fgout_input[3].split()[0])
        output_format = int(fgout_input[4].split()[0])
        if output_format == 1:
            self.output_format = 'ascii'
        elif output_format == 3:
            self.output_format = 'binary'
        print('Reading input for fgno=%i, point_style = %i ' \
                % (self.fgno, self.point_style))
        if point_style == 2:
            self.nx = nx = int(fgmax_input[5].split()[0])
            self.ny = ny = int(fgmax_input[5].split()[1])
            self.x1 = float(fgmax_input[6].split()[0])
            self.y1 = float(fgmax_input[6].split()[1])
            self.x2 = float(fgmax_input[7].split()[0])
            self.y2 = float(fgmax_input[7].split()[1])
        else:
            raise NotImplementedError("fgout not implemented for point_style %i" \
                % point_style)


    def write_to_fgout_data(self, fid):
        """
        Convert fgout data specified in setrun.py to file `fgout_grids.data`
        read in by GeoClaw fortran code.
        """

        print("\n---------------------------------------------- ")
        point_style = self.point_style
        if point_style not in [2]:
            raise NotImplementedError("fgout not implemented for point_style %i" \
                % point_style)
                
        if self.output_format == 'ascii':
            output_format = 1
        elif self.output_format == 'binary':
            output_format = 3
        else:
            raise NotImplementedError("fgout output_format must be ascii or binary")

        # write header, independent of point_style:
        #fid = open(self.input_file_name,'w')
        fid.write("\n")
        fid.write("%i                           # fgno\n" % self.fgno)
        fid.write("%16.10e            # tstart\n"  % self.tstart)
        fid.write("%16.10e            # tend\n"  % self.tend)
        fid.write("%i %s           # nout\n" % (self.nout, 11*" "))
        fid.write("%i %s              # point_style\n" \
                            % (self.point_style,12*" "))
        fid.write("%i %s              # output_format\n" \
                            % (output_format,12*" "))

        print('fgout grid %i has point_style = %i' % (self.fgno, point_style))


        if point_style == 2:
            # 2d grid of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.nx is None:
                dx = self.dx
                nx = int(round((x2-x1)/dx)) + 1
                if abs((nx-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((nx-1)*dx + x1 - x2) = ", \
                          abs((nx-1)*dx + x1 - x2))
                    print("         old x2: %22.16e" % x2)
                    x2 = x1 + dx*(nx-1)
                    print("         resetting x2 to %22.16e" % x2)
            else:
                nx = self.nx
                dx = (x2-x1)/(nx+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)

            if self.ny is None:
                dy = self.dy
                if dy is None:
                    dy = dx
                ny = int(round((y2-y1)/dy)) + 1
                if abs((ny-1)*dy + y1 - y2) > 1e-6:
                    print("Warning: abs((ny-1)*dy + y1 - y2) = ", \
                          abs((ny-1)*dy + y1 - y2))
                    print("         old y2: %22.16e" % y2)
                    y2 = y1 + dy*(ny-1)
                    print("         resetting y2 to %22.16e" % y2)
            else:
                ny = self.ny
                dy = (y2-y1)/(ny+1.)
                if self.dy is not None:
                    print("*** Warning: dy specified over-ridden by: ",dy)

            npts = nx*ny

            fid.write("%i  %i %s          # nx,ny\n" \
                                % (nx,ny,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            #fid.close()


            #print("Created file ", self.input_file_name)
            print("   specifying fgout grid with shape %i by %i, with  %i points" \
                    % (nx,ny,npts))
            print("   lower left  = (%15.10f,%15.10f)" % (x1,y1))
            print("   upper right = (%15.10f,%15.10f)" % (x2,y2))
            print("   dx = %15.10e,  dy = %15.10e" % (dx,dy))

    def read_frame(self, frameno):
        """
        Read a single frame of fgout data.
        """

        #if self.plotdata is None:
        #   self.set_plotdata()
        
        try:
            fr = self.plotdata.getframe(frameno)
        except:
            print('*** Could not read fgout grid %i frame %i from %s' \
                 % (frameno,self.fgno,self.plotdata.outdir))
            raise
        state = fr.states[0]  # only 1 AMR grid
        patch = state.patch

        fgout_frame = FGoutFrame(self, frameno)
        fgout_frame.fgout_grid = self

        fgout_frame.q = state.q

        fgout_frame.t = state.t

        # string version of t in H:M:S format for e.g. titles:
        hours = int(fgout_frame.t/3600.)
        tmin = mod(fgout_frame.t,3600.)
        min = int(tmin/60.)
        sec = int(mod(tmin,60.))
        fgout_frame.t_hms = '%s:%s:%s' \
                            % (hours,str(min).zfill(2),str(sec).zfill(2))
    
        fgout_frame.frameno = frameno
        
        fgout_frame.X = patch.grid.p_centers[0]
        fgout_frame.Y = patch.grid.p_centers[1]

        fgout_frame.x = fgout_frame.X[:,0]
        fgout_frame.y = fgout_frame.Y[0,:]
        dx = fgout_frame.x[1] - fgout_frame.x[0]
        dy = fgout_frame.y[1] - fgout_frame.y[0]
        fgout_frame.delta = [dx, dy]
        
        fgout_frame.extent_centers = [fgout_frame.X.min(),fgout_frame.X.max(),\
                                      fgout_frame.Y.min(),fgout_frame.Y.max()]
                                      
        fgout_frame.extent_edges = [fgout_frame.X.min() - dx/2, \
                                    fgout_frame.X.max() + dx/2, \
                                    fgout_frame.Y.min() - dy/2, \
                                    fgout_frame.Y.max() + dy/2]
        return fgout_frame


# ========================
# Functions for interpolating from fgout grid to arbitrary points,
# useful for example if using velocity field to model particle/debris motion

def make_fgout_fcn_xy(fgout, qoi, method='nearest',
                       bounds_error=False, fill_value=numpy.nan):
    """
    Create a function that can be called at (x,y) and return the qoi
    interpolated in space from the fgout array.
    
    qoi should be a string (e.g. 'h', 'u' or 'v') corresponding to 
    an attribute of fgout.
    
    The function returned takes arguments x,y that can be floats or 
    (equal length) 1D arrays of values that lie within the spatial
    extent of fgout. 
    
    bounds_error and fill_value determine the behavior if (x,y) is not in 
    the bounds of the data, as in scipy.interpolate.RegularGridInterpolator.
    """
    
    from scipy.interpolate import RegularGridInterpolator
    
    try:
        q = getattr(fgout,qoi)
    except:
        print('*** fgout missing attribute qoi = %s?' % qoi)
        
    err_msg = '*** q must have same shape as fgout.X\n' \
            + 'fgout.X.shape = %s,   q.shape = %s' % (fgout.X.shape,q.shape)
    assert fgout.X.shape == q.shape, err_msg
    
    x1 = fgout.X[:,0]
    y1 = fgout.Y[0,:]
    fgout_fcn1 = RegularGridInterpolator((x1,y1), q, method=method,
                bounds_error=bounds_error, fill_value=fill_value)

    def fgout_fcn(x,y):
        """
        Function that can be evaluated at single point or arrays (x,y).
        """
        from numpy import array, vstack
        xa = array(x)
        ya = array(y)
        xyout = vstack((xa,ya)).T
        qout = fgout_fcn1(xyout)
        if len(qout) == 1:
            qout = qout[0]  # return scalar
        return qout

    return fgout_fcn


def make_fgout_fcn_xyt(fgout1, fgout2, qoi, method_xy='nearest',
                       method_t='linear', bounds_error=False,
                       fill_value=numpy.nan):
    """
    Create a function that can be called at (x,y,t) and return the qoi
    interpolated in space and time between the two frames fgout1 and fgout2.
    
    qoi should be a string (e.g. 'h', 'u' or 'v') corresponding to 
    an attribute of fgout.
    
    method_xy is the method used in creating the spatial interpolator,
    and is passed to make_fgout_fcn_xy.
    
    method_t is the method used for interpolation in time, currently only
    'linear' is supported, which linearly interpolates.
    
    bounds_error and fill_value determine the behavior if (x,y,t) is not in 
    the bounds of the data.
    
    The function returned takes arguments x,y (floats or equal-length 1D arrays)
    of values that lie within the spatial extent of fgout1, fgout2
    (which are assumed to cover the same uniform grid at different times)
    and t should be a float that lies between fgout1.t and fgout2.t. 
    """
    
    assert numpy.allclose(fgout1.X, fgout2.X), \
                            '*** fgout1 and fgout2 must have same X'
    assert numpy.allclose(fgout1.Y, fgout2.Y), \
                            '*** fgout1 and fgout2 must have same Y'
    
    t1 = fgout1.t
    t2 = fgout2.t
    #assert t1 < t2, '*** expected fgout1.t < fgout2.t'
    
    fgout1_fcn_xy = make_fgout_fcn_xy(fgout1, qoi, method=method_xy,
                       bounds_error=bounds_error, fill_value=fill_value)
    fgout2_fcn_xy = make_fgout_fcn_xy(fgout2, qoi, method=method_xy,
                       bounds_error=bounds_error, fill_value=fill_value)
                
    def fgout_fcn(x,y,t):
        """
        Function that can be evaluated at single point or arrays (x,y)
        at a single time t.
        """
        from numpy import array, ones
        xa = array(x)
        ya = array(y)
        tol = 1e-6  # to make sure it works ok when called with t=t1 or t=t2
        if t1-tol <= t <= t2+tol:
            alpha = (t-t1)/(t2-t1)
        elif bounds_error:
            errmsg = '*** argument t=%g should be between t1=%g and t2=%g' \
                     % (t,t1,t2)
            raise InputError(errmsg)
        else:
            qout = fill_value * ones(xa.shape)
            return qout

        qout1 = fgout1_fcn_xy(x,y)
        qout2 = fgout2_fcn_xy(x,y)

        if method_t == 'linear':
            if t1 <= t <= t2:
                alpha = (t-t1)/(t2-t1)
                qout = (1-alpha)*qout1 + alpha*qout2
        else:
            raise NotImplementedError('method_t = %s not supported' % method_t)
            
        return qout
        
    return fgout_fcn
    
