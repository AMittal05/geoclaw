r"""
fgout_tools module: $CLAW/geoclaw/src/python/geoclaw/fgout_tools.py

Tools to specify an fgout grid for output on a fixed grid at a sequence
of times, regardless of the AMR structure.

"""

from __future__ import absolute_import
from __future__ import print_function
import os
from numpy import sqrt, ma
import numpy
from six.moves import range
from clawpack.geoclaw import topotools


class FGoutFrame(object):

    def __init__(self, fgout_grid=None, frameno=None):
        self.fgout_grid = fgout_grid
        self.frameno = frameno
        self.t = None
        self.X = None
        self.Y = None
        self.x = None
        self.y = None
        self.extent = None

        # private attributes for those that are only created if
        # needed by the user:
        self._h = None
        self._hu = None
        self._hv = None
        self._eta = None
        self._B = None
        self._u = None
        self._v = None
        self._s = None
        self._hss = None

    # Define attributes such as h as @properties with lazy evaluation:
    # the corresponding array is created and stored only when first
    # accessed by the user.  Those not needed are not created.

    @property
    def h(self):
        if self._h is None:
            #print('+++ setting _h...')
            self._h = self.q[0,:,:]
        #print('+++ getting _h...')
        return self._h

    @property
    def hu(self):
        if self._hu is None:
            self._hu = self.q[1,:,:]
        return self._hu

    @property
    def u(self):
        if self._u is None:
            # set u = hu/h where h>0.01 and to 0 elsewhere:
            self._u = numpy.divide(self.hu, self.h,\
                              out=numpy.zeros(self.h.shape, dtype=float), \
                              where=(self.h>0.01))
        return self._u

    @property
    def hv(self):
        if self._hv is None:
            self._hv = self.q[2,:,:]
        return self._hv

    @property
    def v(self):
        if self._v is None:
            # set v = hv/h where h>0.01 and to 0 elsewhere:
            self._v = numpy.divide(self.hv, self.h,\
                              out=numpy.zeros(self.h.shape, dtype=float), \
                              where=(self.h>0.01))
        return self._v

    @property
    def eta(self):
        """surface eta = h+B"""
        if self._eta is None:
            self._eta = self.q[-1,:,:]
        return self._eta

    @property
    def B(self):
        if self._B is None:
            self._B = self.q[-1,:,:] - self.q[0,:,:]
        return self._B

    @property
    def s(self):
        """speed"""
        if self._s is None:
            self._s = numpy.sqrt(self.u**2 + self.v**2)
        return self._s

    @property
    def hss(self):
        """momentum flux"""
        if self._hss is None:
            self._hss = self.h * self.s**2
        return self._hss

class FGoutGrid(object):

    """
    New class introduced in 5.9.0 to keep store information both about the
    fgout input data and the output generated by a GeoClaw run.
    """

    def __init__(self,fgno=None,outdir=None,output_format=None):


        # GeoClaw input values:
        self.id = ''  # identifier, optional
        self.point_style = None
        self.npts = None
        self.nx = None
        self.ny = None
        self.tstart =  None
        self.tend = None
        self.nout = None
        self.fgno = fgno
        self.outdir = outdir
        self.output_format = output_format

        # Other possible GeoClaw inputs:
        self.x = None
        self.y = None
        self.X = None
        self.Y = None
        self.dx = None
        self.dy = None

        self._plotdata = None

    # Create plotdata of class clawpack.visclaw.ClawPlotData
    # only when needed for reading GeoClaw output, 
    # since this must be done after fgno, outdir, output_format
    # have been specified:

    @property
    def plotdata(self):
        if self._plotdata is None:
            self._plotdata = self.set_plotdata()
        return self._plotdata

    def set_plotdata(self):
        """
        Create a plotdata, assuming attributes fgno, outdir, output_format
        have all been set.
        """
        from clawpack.visclaw.data import ClawPlotData

        assert self.fgno is not None, '*** fgno must be set'
        assert self.outdir is not None, '*** outdir must be set'
        assert self.output_format is not None, '*** output_format must be set'
        if 0:
            print('+++ creating plotdata for fgno=%i, outdir=%s, format=%s' \
                  % (self.fgno,self.outdir,self.output_format))

        plotdata = ClawPlotData()
        plotdata.outdir = self.outdir
        plotdata.format = self.output_format
        plotdata.file_prefix = 'fgout%s' % str(self.fgno).zfill(4)
        if self.output_format=='binary':
            file_prefix_str = plotdata.file_prefix + '.b'
        else:
            file_prefix_str = plotdata.file_prefix + '.q'
        return plotdata


    def read_fgout_grids_data(self, fgno=None, data_file='fgout_grids.data'):
        """
        Read input info for fgout grid number fgno from the data file
        fgout_grids.data, which should have been created by setrun.py.
        This file now contains info about all fgout grids.
        """
        if fgno is not None:
            self.fgno = fgno
        assert self.fgno is not None, '*** fgno must be set'

        with open(data_file) as filep:
            lines = filep.readlines()
        fgout_input = None
        for lineno,line in enumerate(lines):
            if 'fgno' in line:
                if int(line.split()[0]) == self.fgno:
                    fgout_input = lines[lineno+1:]
                    #print('Found line %i: %s' % (lineno,line))
                    break

        if fgout_input is None:
            raise ValueError('fgout grid fgno = %i not found in %s' \
                             % (fgno, data_file))

        self.tstart = float(fgout_input[0].split()[0])
        self.tend = float(fgout_input[1].split()[0])
        self.nout = int(fgout_input[2].split()[0])
        self.point_style = point_style = int(fgout_input[3].split()[0])
        output_format = int(fgout_input[4].split()[0])
        if output_format == 1:
            self.output_format = 'ascii'
        elif output_format == 3:
            self.output_format = 'binary'
        print('Reading input for fgno=%i, point_style = %i ' \
                % (self.fgno, self.point_style))
        if point_style == 2:
            self.nx = nx = int(fgmax_input[5].split()[0])
            self.ny = ny = int(fgmax_input[5].split()[1])
            self.x1 = float(fgmax_input[6].split()[0])
            self.y1 = float(fgmax_input[6].split()[1])
            self.x2 = float(fgmax_input[7].split()[0])
            self.y2 = float(fgmax_input[7].split()[1])
        else:
            raise NotImplementedError("fgout not implemented for point_style %i" \
                % point_style)


    def write_to_fgout_data(self, fid):

        print("\n---------------------------------------------- ")
        point_style = self.point_style
        if point_style not in [2]:
            raise NotImplementedError("fgout not implemented for point_style %i" \
                % point_style)
                
        if self.output_format == 'ascii':
            output_format = 1
        elif self.output_format == 'binary':
            output_format = 3
        else:
            raise NotImplementedError("fgout output_format must be ascii or binary")

        # write header, independent of point_style:
        #fid = open(self.input_file_name,'w')
        fid.write("\n")
        fid.write("%i                           # fgno\n" % self.fgno)
        fid.write("%16.10e            # tstart\n"  % self.tstart)
        fid.write("%16.10e            # tend\n"  % self.tend)
        fid.write("%i %s           # nout\n" % (self.nout, 11*" "))
        fid.write("%i %s              # point_style\n" \
                            % (self.point_style,12*" "))
        fid.write("%i %s              # output_format\n" \
                            % (output_format,12*" "))

        print('fgout grid %i has point_style = %i' % (self.fgno, point_style))


        if point_style == 2:
            # 2d grid of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.nx is None:
                dx = self.dx
                nx = int(round((x2-x1)/dx)) + 1
                if abs((nx-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((nx-1)*dx + x1 - x2) = ", \
                          abs((nx-1)*dx + x1 - x2))
                    print("         old x2: %22.16e" % x2)
                    x2 = x1 + dx*(nx-1)
                    print("         resetting x2 to %22.16e" % x2)
            else:
                nx = self.nx
                dx = (x2-x1)/(nx+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)

            if self.ny is None:
                dy = self.dy
                if dy is None:
                    dy = dx
                ny = int(round((y2-y1)/dy)) + 1
                if abs((ny-1)*dy + y1 - y2) > 1e-6:
                    print("Warning: abs((ny-1)*dy + y1 - y2) = ", \
                          abs((ny-1)*dy + y1 - y2))
                    print("         old y2: %22.16e" % y2)
                    y2 = y1 + dy*(ny-1)
                    print("         resetting y2 to %22.16e" % y2)
            else:
                ny = self.ny
                dy = (y2-y1)/(ny+1.)
                if self.dy is not None:
                    print("*** Warning: dy specified over-ridden by: ",dy)

            npts = nx*ny

            fid.write("%i  %i %s          # nx,ny\n" \
                                % (nx,ny,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            #fid.close()


            #print("Created file ", self.input_file_name)
            print("   specifying fgout grid with shape %i by %i, with  %i points" \
                    % (nx,ny,npts))
            print("   lower left  = (%15.10f,%15.10f)" % (x1,y1))
            print("   upper right = (%15.10f,%15.10f)" % (x2,y2))
            print("   dx = %15.10e,  dy = %15.10e" % (dx,dy))

    def read_frame(self, frameno):
        """
        Read a single frame of fgout data.
        """

        #if self.plotdata is None:
        #   self.set_plotdata()
        
        print('Reading fgout grid %i frame %i from %s' \
                % (frameno,self.fgno,self.plotdata.outdir))
        try:
            fr = self.plotdata.getframe(frameno)
        except:
            print('*** Could not read file')
            raise
        state = fr.states[0]  # only 1 AMR grid
        patch = state.patch

        fgout_frame = FGoutFrame(self, frameno)

        fgout_frame.q = state.q

        fgout_frame.t = state.t
        fgout_frame.frameno = frameno
        
        fgout_frame.X = patch.grid.p_centers[0]
        fgout_frame.Y = patch.grid.p_centers[1]

        fgout_frame.x = fgout_frame.X[:,0]
        fgout_frame.y = fgout_frame.Y[0,:]
        
        fgout_frame.extent = [fgout_frame.X.min(),fgout_frame.X.max(),\
                              fgout_frame.Y.min(),fgout_frame.Y.max()]
        return fgout_frame

